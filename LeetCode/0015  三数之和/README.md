##### 题目描述

给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

**示例：**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```





##### 暴力破解法

三层循环，计算和，符合的则返回



##### 排序 + 双指针

题目中要求找到所有「不重复」且和为 00 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 00，即

```
[0, 0, 0, 0, 0, ..., 0, 0, 0]
```





任意一个三元组的和都为 00。如果我们直接使用三重循环枚举三元组，会得到 O(N^3)*O*(*N*3) 个满足题目要求的三元组（其中 N*N* 是数组的长度）时间复杂度至少为 O(N^3)*O*(*N*3)。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。

「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：

- 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；
- 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。

也就是说，我们枚举的三元组 (a, b, c)(*a*,*b*,*c*) 满足 a \leq b \leq c*a*≤*b*≤*c*，保证了只有 (a, b, c)(*a*,*b*,*c*) 这个顺序会被枚举到，而 (b, a, c)(*b*,*a*,*c*)、(c, b, a)(*c*,*b*,*a*) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。

同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为

```
[0, 1, 2, 2, 2, 3]
 ^  ^  ^
```



我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)(0,1,2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)(0,1,2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 33，枚举三元组 (0, 1, 3)(0,1,3)。



这种方法的时间复杂度仍然为 O(N^3)*O*(*N*3)，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 a*a* 和 b*b*，那么只有唯一的 c*c* 满足 a+b+c=0*a*+*b*+*c*=0。当第二重循环往后枚举一个元素 b'*b*′ 时，由于 b' > b*b*′>*b*，那么满足 a+b'+c'=0*a*+*b*′+*c*′=0 的 c'*c*′ 一定有 c' < c*c*′<*c*，即 c'*c*′ 在数组中一定出现在 c*c* 的左侧。也就是说，我们可以从小到大枚举 b*b*，**同时**从大到小枚举 c*c*，即**第二重循环和第三重循环实际上是并列的关系**。

有了这样的发现，我们就可以保持第二重循环不变，而将**第三重循环变成一个从数组最右端开始向左移动的指针**

**这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)*O*(*N*2) 减少至 O(N)*O*(*N*)。为什么是 O(N)*O*(*N*) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b*b*），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)*O*(*N*)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)*O*(*N*)。**

注意到我们的伪代码中还有第一重循环，时间复杂度为 O(N)*O*(*N*)，因此枚举的总时间复杂度为 O(N^2)*O*(*N*2)。由于排序的时间复杂度为 O(N \log N)*O*(*N*log*N*)，在渐进意义下小于前者，因此算法的总时间复杂度为 O(N^2)*O*(*N*2)。



```kotlin
class Solution {
    fun threeSum(nums: IntArray): List<List<Int>> {
        //排序，时间复杂度是O(nlog(n))
        var sortedNums = nums.sortedArray()

        //返回的链表
        var ret = ArrayList<List<Int>>()

        for (i in sortedNums.indices) {
            //保证不重复计算相同数字
            if (i != 0 && sortedNums[i] == sortedNums[i - 1]) {
                continue
            }

            var k = sortedNums.size - 1

            for (j in i + 1 until sortedNums.size) {
                if (j != i + 1 && sortedNums[j] == sortedNums[j - 1]) {
                    continue
                }

                while (j < k && (sortedNums[i] + sortedNums[j] > -1 * sortedNums[k])) {
                    k--
                }

                if (j >= k) {
                    break
                }

                var sum = sortedNums[i] + sortedNums[j] + sortedNums[k]

                if (sum == 0) {
                    var tem = ArrayList<Int>()
                    tem.add(sortedNums[i])
                    tem.add(sortedNums[j])
                    tem.add(sortedNums[k])
                    ret.add(tem)
                }
            }
        }

        return ret
    }
}
```

