##### 题目描述

给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

 

**示例：**

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

 

**提示：**

- `1 <= len(A), len(B) <= 1000`
- `0 <= A[i], B[i] < 100`





##### 1 . 暴力破解法 

```python
ans = 0
for i in [0 .. A.length - 1]
    for j in [0 .. B.length - 1]
        k = 0
        while (A[i+k] == B[j+k]) do   # and i+k < A.length etc.
            k += 1
        end while
        ans = max(ans, k)
    end for
end for
```



##### 2 . 动态规划

在暴力破解中，对于最坏情况，a[i]和b[j]比较了min(i + 1 , j + 1)次，比如 i = A.length - 1 , j = B.length - 1时，最坏的就是A，B完全相等时，此时A[A.length - 1] 和 B[B.length - 1]比较了A.length次。那么反过来，A[A.length - 1]只比较一次，当下次想要再次比较时，那肯定是上一次（A.length - 2 ,即倒数第二位的互相比较）已经相等，且上一次的最长长度等于下一次的长度 + 1。当然，如果上次的比较不相等，那么，上次的最长长度就是0.所以可以得出递推公式
$$
f[i][j] = f[i + 1][j + 1] + 1
$$

```kotlin
class Solution {
    fun findLength(A: IntArray, B: IntArray): Int {
        val dp = Array<Array<Int>>(A.size + 1){ Array(B.size + 1){0} }
        var max = 0

        for (i in A.size - 1 downTo 0) {
            for (j in B.size - 1 downTo 0) {
                if (A[i] == B[j]) {
                    dp[i][j] = 1 + dp[i + 1][j + 1]
                }
            }
        }

        for (i in dp) {
            for (j in i) {
                max = Math.max(max,j)
            }
        }

        return max
    }
}
```





##### 3. 滑动窗口

核心是，我不管前后，我只管当前对应的 i 时，A[i] == B[i] ，则 k + 1，那么怎么保证遍历所有情况呢？滑动其中一个数组撒，把其中一个数组的开始元素和另外一个数组的任何一个元素都对其一遍，最后就是所有情况都考虑到了，最后最大值就是结果，代码实现比较简单，不贴代码了



##### 4 . 二分查找 + 哈希（还没看，有时间再研究研究）

如果数组 `A` 和 `B` 有一个长度为 `k` 的公共子数组，那么它们一定有长度为 `j <= k` 的公共子数组。这样我们可以通过二分查找的方法找到最大的 `k`。

而为了优化时间复杂度，在二分查找的每一步中，我们可以考虑使用哈希的方法来判断数组 `A` 和 `B` 中是否存在相同特定长度的子数组。

注意到序列内元素值小于 100100 ，我们使用 Rabin-Karp 算法来对序列进行哈希。具体地，我们制定一个素数 `base`，那么序列 `S` 的哈希值为：

\mathrm{hash}(S) = \sum_{i=0}^{|S|-1} base^{|S|-(i+1)} \times S[i]hash(*S*)=*i*=0∑∣*S*∣−1*b**a**s**e*∣*S*∣−(*i*+1)×*S*[*i*]

形象地说，就是把 `S` 看成一个类似 `base` 进制的数（左侧为高位，右侧为低位），它的十进制值就是这个它的哈希值。由于这个值一般会非常大，因此会将它对另一个素数 `mod` 取模。

当我们要在一个序列 `S` 中算出所有长度为 `len` 的子序列的哈希值时，我们可以用类似滑动窗口的方法，在线性时间内得到这些子序列的哈希值。例如，如果我们当前得到了 `S[0:len]` 的哈希值，希望算出 `S[1:len+1]` 的哈希值时，有下面这个公式：

\mathrm{hash}(S[1:len+1]) = (\mathrm{hash}(S[0:len]) - base^{len-1} \times S[0]) \times base + S[len]hash(*S*[1:*l**e**n*+1])=(hash(*S*[0:*l**e**n*])−*b**a**s**e**l**e**n*−1×*S*[0])×*b**a**s**e*+*S*[*l**e**n*]

> 这里借用了 `Python` 表示数组的方法，`A[i:j]` 表示数组 `A` 中索引 `i` 到索引 `j - 1` 的范围对应的子数组。
>
> 公式的含义为，删去最高位 `S[0]`，其余位自动进一，并补上最低位 `S[len]`。

在二分查找的每一步中，我们使用哈希表分别存储这两个数组的所有长度为 `len` 的子数组的哈希值，将它们的哈希值进行比对，如果两序列存在相同的哈希值，则认为两序列存在相同的子数组。为了防止哈希碰撞，我们也可以在发现两个子数组的哈希值相等时，进一步校验它们本身是否确实相同，以确保正确性。但该方法在本题中很难发生哈希碰撞，因此略去进一步校验的部分。