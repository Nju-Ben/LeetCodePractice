##### 题目描述：

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 `0` 分开始，并在她的得分少于 `K` 分时抽取数字。 抽取时，她从 `[1, W]` 的范围中随机获得一个整数作为分数进行累计，其中 `W` 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 `K` 分时，她就停止抽取数字。 爱丽丝的分数不超过 `N` 的概率是多少？

 

**示例** **1****：**

```
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。
```

**示例** **2****：**

```
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
```

**示例** **3****：**

```
输入：N = 21, K = 17, W = 10
输出：0.73278
```





#### 方法一：动态规划

爱丽丝获胜的概率只和下一轮开始前的得分有关，因此根据得分计算概率。

令 dp[x] 为得分为x时开始游戏并且获胜的概率，目标是求 dp[0] 的值。

根据规则，当分数达到或超过 **K** 时游戏结束，游戏结束时，如果分数不超过 **N**则获胜，如果分数超过 **N** 则失败。因此，

当得分**N>x>K**时，dp[x] =1;

当得分**x>N**时，dp[x] =0;

当得分**x<K**时；每次抽牌的概率都是1/W；

![image-20200616012706600](C:\Users\徐不懂的作坊\AppData\Roaming\Typora\typora-user-images\image-20200616012706600.png)

如图积分为16时，还要进行一次抽牌，抽完后的积分为17~26，其中积分为17~21赢的概率是1；而积分为22~26时，赢的概率为0；所以积分为16时赢的概率为

dp[16]=(dp[16+1]+dp[16+2]+dp[16+3]+...+dp[16+10])×1/10 =0.5;

dp[15] = (dp[15+1]+dp[15+2]+dp[15+3]+...+dp[15+10]) x1/10=0.55;

......

所以dp[x] = (dp[x+1] +dp[x+2] +dp[x+3] + ... + dp[x+10]) x 1/w;

dp[0]即为所求；

##### 实现如下：

积分区间为[0，k+n-1]，所以申明一个该大小的double数组，数组中对应角标存放积分为此时赢的概率；dp[0]就是最后的结果；从后往前推即可

```
class Solution {
public:
    double new21Game(int N, int K, int W) {
        double dp[K + W];
        double sum = 0.0;
        for (int i = K; i < K + W; i++) {
            dp[i] = (i <= N ? 1.0 : 0.0);
            sum += dp[i];
        }
        for (int i = K-1; i > -1; i--) {
            dp[i] = sum / W;
            sum = sum - dp[i + W] + dp[i];
        }
        return dp[0];

    }
};
```

